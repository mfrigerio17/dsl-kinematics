/*
 * generated by Xtext
 */
package iit.dsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator

import iit.dsl.kinDsl.PrismaticJoint
import iit.dsl.kinDsl.RevoluteJoint
import iit.dsl.kinDsl.AbstractLink
import iit.dsl.kinDsl.Robot
import iit.dsl.kinDsl.InertiaParams


class KinDslGenerator implements IGenerator {
    extension Common common = new Common()
    FramesTransforms frTransforms = new FramesTransforms()

    override void doGenerate(Resource resource, IFileSystemAccess fsa) {
        val robot = resource.contents.head as Robot;
        fsa.generateFile(robot.name+".urdf", generateURDFmodel(robot))
        fsa.generateFile(robot.name+".sd", generateSDFASTmodel(robot))
        fsa.generateFile(FramesTransforms::fileName(robot), frTransforms.coordinateTransformsDSLDocument(robot))
    }

    def testITensorRotation(Robot hyl) {
        val hip = hyl.getLinkByName("hip")
        val original = hip.inertiaParams;
        val comFrame = hip.frames.get(0);
        val transf   = Utilities::rototranslate(original,
            comFrame.transform.translation.x.asFloat,
            comFrame.transform.translation.y.asFloat,
            comFrame.transform.translation.z.asFloat,
            comFrame.transform.rotation.x.asFloat,  //(-Math::PI/5) as float,//
            comFrame.transform.rotation.y.asFloat,  //(-Math::PI/6) as float,//
            comFrame.transform.rotation.z.asFloat, //(-Math::PI/3) as float)//
            false);
        System::out.println(transf.mass)
        System::out.println('''«transf.com.x.asFloat»  «transf.com.y.asFloat»  «transf.com.z.asFloat»''')
        System::out.println('''«transf.ix»  «transf.iy»  «transf.iz»  «transf.ixy»  «transf.ixz»  «transf.iyz»''')
        //System::out.println(transf.mass)
    }

    /**
     * Generates and xml URDF description of the robot, as specified in the ROS documentation.
     * The URDF file format requires the inertia tensor to be expressed in a reference frame
     * with origin in the center of mass. Therefore this generator takes the inertia tensor
     * expressed in the link-default-frame and translates it to the COM before printing the values.
     */
    def generateURDFmodel(Robot robot) '''
    <robot name="«robot.name»">
    «FOR link : robot.abstractLinks»
        «val inertia_lf = link.linkFrameInertiaParams /*inertia params expressed in the default link frame*/»
        «val com = inertia_lf.com»
        «val inertia = /*inertia params expressed in the frame centered in the COM*/
             Utilities::rototranslate(inertia_lf, com.x.asFloat,com.y.asFloat,com.z.asFloat,0,0,0,false)»
        <link name="«link.name»">
            <inertial>
                <origin xyz="«inertia_lf.com.x.str» «inertia_lf.com.y.str» «inertia_lf.com.z.str»"/>
                <mass value="«inertia.mass»"/>
                <inertia ixx="«inertia.ix»" iyy="«inertia.iy»" izz="«inertia.iz»" ixy="«inertia.ixy»" ixz="«inertia.ixz»" iyz="«inertia.iyz»"/>
            </inertial>
        </link>
    «ENDFOR»
    «FOR joint : robot.joints»
        «val frame = joint.refFrame»
        <joint name="«joint.name»" type="«joint.typeString»">
            <origin xyz="«frame.translation.listCoordinates()»" rpy="«frame.rotation.x.asFloat» «frame.rotation.y.asFloat» «frame.rotation.z.asFloat»"/>
            <parent link="«joint.predecessorLink.name»"/>
            <child  link="«joint.successorLink.name»"/>
            <limit effort="30" velocity="1.0"/>
            <axis xyz="0 0 1"/>
        </joint>
    «ENDFOR»
    </robot>
    '''

    def generateSDFASTmodel(Robot robot) '''
        #  This is an SD/FAST input file describing the robot «robot.name»
        #
        #  This file has been automatically generated by the robotics code generator
        #   developed by Marco Frigerio at the Italian Institute of Technology.
        #      November 2012

        language = c
        gravity = 0 0 -9.8

        «IF robot.base.floating»
            # Floating base is not supported yet!!! #
        «ELSE»
            «val iparams = sdfast_inertiaParams(robot.base)»
            body = «robot.base.name»
              inb = $ground
              joint = weld
              mass = «iparams.mass»
              inertia =
                «iparams.ix» «iparams.ixy» «iparams.ixz»
                «iparams.ixy» «iparams.iy» «iparams.iyz»
                «iparams.ixz» «iparams.iyz» «iparams.iz»
              bodytojoint = 0 0 0
        «ENDIF»

        «FOR link : robot.links»
            «val iparams = sdfast_inertiaParams(link)»
            body = «link.name»
              inb = «link.parent.name»
              joint = «sdfast_jointType(link.connectingJoint)»
              pin = 0 0 1
              mass = «iparams.mass»
              inertia =
                «iparams.ix» «iparams.ixy» «iparams.ixz»
                «iparams.ixy» «iparams.iy» «iparams.iyz»
                «iparams.ixz» «iparams.iyz» «iparams.iz»
              bodytojoint = «sdfast_bodyToJointVector(iparams)»

        «ENDFOR»
    '''
    def private dispatch sdfast_jointType(PrismaticJoint j) '''slider'''
    def private dispatch sdfast_jointType(RevoluteJoint  j) '''pin'''
    def private InertiaParams sdfast_inertiaParams(AbstractLink body) {
        val iparams = body.linkFrameInertiaParams

        val iparams_new = /*inertia params expressed in the frame centered in the COM*/
                Utilities::rototranslate(
                iparams,
                iparams.com.x.asFloat,
                iparams.com.y.asFloat,
                iparams.com.z.asFloat,
                0,0,0,false //TODO compute the angles
            )

        return iparams_new
    }
    def private sdfast_bodyToJointVector(InertiaParams ip) {
        val x = Utilities::invert(ip.com.x.asFloat)
        val y = Utilities::invert(ip.com.y.asFloat)
        val z = Utilities::invert(ip.com.z.asFloat)
        return '''«x» «y» «z»'''
    }
//    def private sdfast_inbToJointVector(AbstractLink body) {
//        val joint = body.connectingJoint
//        joint.refFrame
//    }


    def test_getJoint(Robot robot) {
        System::out.println('''
        «FOR link : robot.links»
        Parent «link.parent.name», child: «link.name»  -  Joint: «getJoint(link.parent, link).name»
        «ENDFOR»'''.toString() );
    }

    def test_jointFromVariableName(Robot robot) {
        System::out.println('''
        «FOR joint : robot.joints»
        Joint «joint.name», variable: «joint.variableName», joint again: «(robot.getJointFromVariableName(joint.variableName.toString())).name»
        «ENDFOR»'''.toString() );
    }
    /*
    '''
        «FOR link : robot.abstractLinks»
            «FOR link2 : robot.abstractLinks»
                «val chain = common.buildChain(link, link2)»
                «link.name» - «link2.name»   :   «FOR AbstractLink el : chain» «el.name»«ENDFOR»
            «ENDFOR»
        «ENDFOR»

    '''
    //*/
    /*
    var AbstractLink found;
        for(AbstractLink l: robot.abstractLinks) {
            found = common.getLinkByName(robot, l.name)
            if(! found.equals(l)) {
                throw new RuntimeException("test failed!")
            }
        }
    //throw new RuntimeException("OK!!")
    //*/
    /*
    '''
        «FOR link : robot.abstractLinks»
        Link «link.name» moved by  «link.connectingJoint»
        «ENDFOR»
        «FOR link : robot.links»
        Link «link.name» connected from  «link.parent.name»  via  «link.connectingJoint.name»
        «ENDFOR»
        «FOR joint : robot.joints»
        Joint «joint.name» connecting  «joint.successorLink.name»
        «ENDFOR»
    '''
    //*/
    /*
    '''
        «FOR link : robot.links»
        Link «link.name» connected from  «link.parent.name»  via  «link.connectingJoint.name»
        «ENDFOR»
        «FOR joint : robot.joints»
        Joint «joint.name» connecting  «joint.successorLink.name»
        «ENDFOR»
    '''
    //*/


    def temp(Resource resource) '''
        «FOR r : resource.contents»
        «r.eClass.name»
        «ENDFOR»'''


}
