package iit.dsl.generator.matlab

import iit.dsl.kinDsl.RevoluteJoint
import iit.dsl.kinDsl.PrismaticJoint
import iit.dsl.kinDsl.Joint
import iit.dsl.kinDsl.Robot
import iit.dsl.kinDsl.AbstractLink

import iit.dsl.generator.Common
import iit.dsl.kinDsl.Vector3

/**
 * Generator of a matlab file which defines a structure describing the robot
 * kinematic tree, according to the model described in "A beginner's guide to
 * 6-D vectors (part 2)" by Roy Featherstone. This generated code is compatible
 * with the 'spatial_v2' code by Featherstone.
 */
class RoysModel {
    def public static functionName(Robot r) {
        return r.name
    }

    def scriptBody(Robot robot)
    {
        var boolean parametric = false
        if(iit::dsl::generator::common::Parameters::kinematicsIsParametric(robot) ||
            iit::dsl::generator::common::Parameters::massPropertiesAreParametric(robot))
            parametric = true

        return '''
        «val structName = robot.name.toLowerCase + "model"»
        «IF parametric»
            function «structName» = «functionName(robot)»(params)
        «ELSE»
            function «structName» = «functionName(robot)»()
        «ENDIF»
        % A structure describing the robot kinematics and the inertia
        %  parameters according to the model described in "A beginner's guide
        %  to 6-D vectors (part 2)" by Roy Featherstone.
        %
        %  This file has been automatically generated by the robotics code
        %  generator developed by Marco Frigerio at the Italian Institute of
        %  Technology.

        «IF parametric»
            «InertiaProperties::inertiaParamsStruct» = params.«InertiaProperties::inertiaParamsStruct»;
        «ENDIF»

        «structName».robotname = '«robot.name»';

        «IF robot.base.isFloating»
            «structName».NB = «robot.movingBodiesCount» + 5;
            «structName».parent = zeros(1, «robot.links.size» + 5);

            «structName».jtype(1:6) = {'Px', 'Py', 'Pz', 'Rx', 'Ry', 'Rz'};
            «structName».parent(1:6) = [0 1 2 3 4 5];

            for i = 1:6
                % For the 'I' field, a loop until i=5 would be enough
                «structName».I{i} = mcI( 0, [0,0,0], zeros(3) );
                % 'Xtree' instead must be initialized up to i=6
                «structName».Xtree{i} = eye(6);
            end

            «FOR l : robot.links»
                «IF l.parent.equals(robot.base)»
                    «structName».parent(«l.ID»+6) = 6;
                «ELSE»
                    «structName».parent(«l.ID»+6) = «l.parent.ID»+6;
                «ENDIF»
            «ENDFOR»

            «FOR j : robot.joints»
                «structName».jtype{«j.ID»+6} = «jointType(j)»;
            «ENDFOR»

            «FOR j : robot.joints»
                «structName».Xtree{«j.ID»+6} = «jointTransform(j)»;
            «ENDFOR»

            «inertiaParams(robot.base, structName+".I{6}")»
            «FOR l : robot.links»
                «inertiaParams(l, structName+".I{"+(l.ID+6)+"}")»

            «ENDFOR»
        «ELSE»
            «structName».NB = «robot.movingBodiesCount»;
            «structName».parent = zeros(1, «robot.links.size»);

            «FOR l : robot.links»
                «structName».parent(«l.ID») = «l.parent.ID»;
            «ENDFOR»

            «FOR j : robot.joints»
                «structName».jtype{«j.ID»} = «jointType(j)»;
            «ENDFOR»

            «FOR j : robot.joints»
                «structName».Xtree{«j.ID»} = «jointTransform(j)»;
            «ENDFOR»

            «FOR l : robot.links»
                «inertiaParams(l, structName+".I{"+l.ID+"}")»

            «ENDFOR»
        «ENDIF»
    '''
    }

    def private dispatch jointType(RevoluteJoint j)  ''' 'Rz' '''
    def private dispatch jointType(PrismaticJoint j) ''' 'Pz' '''
    def private jointTransform(Joint j) '''
        rotz(«Parameters::value(j.refFrame.rotation.z, angles_struct)» ) * ...
        roty(«Parameters::value(j.refFrame.rotation.y, angles_struct)» ) * ...
        rotx(«Parameters::value(j.refFrame.rotation.x, angles_struct)» ) * ...
        xlt(«lengthsVector(j.refFrame.translation)»);
    '''

    def private lengthsVector(Vector3 v)
        '''[«Parameters::value(v.x, lengths_struct)» «Parameters::value(v.y, lengths_struct)» «Parameters::value(v.z, lengths_struct)»]'''

    def private inertiaParams(AbstractLink l, CharSequence assignToMe) '''
        «val inertia_lf = l.linkFrameInertiaParams»

        tmpI   = «InertiaProperties::tensor(inertia_lf)»;
        tmpC   = skew(«InertiaProperties::com(inertia_lf)»);
        tmpMass= «InertiaProperties::value(inertia_lf.mass)»;
        «assignToMe» = [tmpI, tmpMass*tmpC; tmpMass*tmpC', eye(3)*tmpMass];
    '''

    def private static angles_struct()  '''params.«Parameters::anglesParamsStruct»'''
    def private static lengths_struct() '''params.«Parameters::lengthsParamsStruct»'''

    private extension Common common = Common::getInstance();
}