package iit.dsl.generator.misc

import iit.dsl.kinDsl.Robot

import iit.dsl.generator.Common
import iit.dsl.generator.Utilities
import iit.dsl.generator.common.TreeUtils
import iit.dsl.generator.common.Vector3D

import iit.dsl.kinDsl.PrismaticJoint
import iit.dsl.kinDsl.RevoluteJoint
import iit.dsl.kinDsl.AbstractLink
import iit.dsl.kinDsl.InertiaParams
import iit.dsl.kinDsl.FloatLiteral
import iit.dsl.kinDsl.Joint


class Misc {
    static Misc singleton = null

    def static Misc getInstance() {
        if(singleton == null) {
            singleton = new Misc()
        }
        return singleton
    }



    private extension Common common = new Common()

    private new() { }

    /**
     * Generates and xml URDF description of the robot, as specified in the ROS
     * documentation.
     *
     * The URDF file format requires the inertia tensor to be expressed in a reference frame
     * with origin in the center of mass. Therefore this generator takes the inertia tensor
     * expressed in the link-default-frame and translates it to the COM before printing the values.
     * In addition, the URDF format requires the elements of the inertia tensor,
     * and not the inertia moments as in the Kinematics-DSL format; therefore
     * the signs of the centrifugal moments are swapped.
     */
    def public URDF_ROS_model(Robot robot) '''
    <robot name="«robot.name»">
        «IF robot.base.floating»
            <link name="world" />
        «ENDIF»
        <link name="«robot.base.name»">
            «IF robot.base.floating»
                «URDF_inertialSection(robot.base)»
            «ENDIF»
        </link>
        «FOR link : robot.links»
            <link name="«link.name»">
                «URDF_inertialSection(link)»
            </link>
        «ENDFOR»
        «IF robot.base.floating»
            <joint name="fbj" type="floating">
                <parent link="world"/>
                <child  link="«robot.base.name»"/>
            </joint>
        «ENDIF»
        «FOR joint : robot.joints»
            «val frame = joint.refFrame»
            «val rpy = Utilities::intrinsicToExtrinsic_xyz(frame.rotation.x.asFloat,frame.rotation.y.asFloat,frame.rotation.z.asFloat)»
            <joint name="«joint.name»" type="«joint.typeString»">
                <origin xyz="«frame.translation.listCoordinates()»" rpy="«rpy.get(0)» «rpy.get(1)» «rpy.get(2)»"/>
                <parent link="«joint.predecessorLink.name»"/>
                <child  link="«joint.successorLink.name»"/>
                <limit effort="30" velocity="1.0"/>
                <axis xyz="0 0 1"/>
            </joint>
        «ENDFOR»
    </robot>
    '''
    def private URDF_inertialSection(AbstractLink link)
        '''
        <inertial>
            «val inertia_lf = link.linkFrameInertiaParams /*inertia params expressed in the default link frame*/»
            «val inertia = getURDFInertiaParams(inertia_lf)»
            <origin xyz="«inertia_lf.com.listCoordinates()»"/>
            <mass value="«inertia.mass.str»"/>
            <inertia ixx="«inertia.ix.str»" iyy="«inertia.iy.str»" izz="«inertia.iz.str»" ixy="«inertia.ixy.str»" ixz="«inertia.ixz.str»" iyz="«inertia.iyz.str»"/>
        </inertial>
        '''

    def private getURDFInertiaParams(InertiaParams inertia_lf) {
        val com = inertia_lf.com
        val inertia_com = // params expressed in the frame centered in the COM
             Utilities::rototranslate(inertia_lf, com.x.asFloat,com.y.asFloat,com.z.asFloat,0,0,0,false)

        // Invert the centrifugal moments, because URDF wants the elements of
        //  the inertia tensor, not the moments
        inertia_com.setIxy( (inertia_com.ixy as FloatLiteral).invert )
        inertia_com.setIxz( (inertia_com.ixz as FloatLiteral).invert )
        inertia_com.setIyz( (inertia_com.iyz as FloatLiteral).invert )
        return inertia_com
    }

    /**
     * Generates the content of an SD/FAST input file representing the given robot
     */
    def SDFAST_model(Robot robot) '''
        #  This is an SD/FAST input file describing the robot «robot.name»
        #
        #  This file has been automatically generated by the robotics code generator
        #   developed by Marco Frigerio at the Italian Institute of Technology.
        #      June 2015

        language = c
        gravity = 0 0 -9.8

        «val Ib = sdfast_inertiaParams(robot.base, null)»
        body = «robot.base.name»
          inb   = $ground
          mass  = «robot.base.inertiaParams.mass.str»
          inertia =
            «Ib.get(0).get(0)» «Ib.get(0).get(1)» «Ib.get(0).get(2)»
            «Ib.get(1).get(0)» «Ib.get(1).get(1)» «Ib.get(1).get(2)»
            «Ib.get(2).get(0)» «Ib.get(2).get(1)» «Ib.get(2).get(2)»
          bodytojoint = 0 0 0
          «IF robot.base.floating»
              joint = free
              pin = 1 0 0
              pin = 0 1 0
              pin = 0 0 1
              inbtojoint = 0 0 0
          «ELSE»
              joint = weld
          «ENDIF»


        «val rotations = TreeUtils::getLinkToBaseRotationMatrices(robot.base)»
        «FOR link : robot.links»
            «val I       = sdfast_inertiaParams(link, rotations.get(link))»
            «val joint   = link.connectingJoint»
            «val parent  = link.parent»
            body = «link.name»
              inb   = «parent.name»
              joint = «sdfast_jointType(joint)»
              pin   = «sdfast_jointAxis(joint, rotations.get(parent))»
              mass  = «link.inertiaParams.mass.str»
              inertia =
                «I.get(0).get(0)» «I.get(0).get(1)» «I.get(0).get(2)»
                «I.get(1).get(0)» «I.get(1).get(1)» «I.get(1).get(2)»
                «I.get(2).get(0)» «I.get(2).get(1)» «I.get(2).get(2)»
              bodytojoint = «sdfast_successorToJointVector(link, rotations.get(link))»
              inbtojoint  = «sdfast_predecessorToJointVector(parent, joint, rotations.get(parent))»


        «ENDFOR»
    '''
    def private dispatch sdfast_jointType(PrismaticJoint j) '''slider'''
    def private dispatch sdfast_jointType(RevoluteJoint  j) '''pin'''
    def private double[][] sdfast_inertiaParams(AbstractLink body, double[][] R)
    {
        val iparams = body.linkFrameInertiaParams

        val translation = Vector3D::convert(iparams.com)
        val tensor      = Utilities::getInertiaTensor(iparams)
        var double[][] iparams_new = null

        // Calculate the inertia params expressed in the frame centered in
        //  the COM, and aligned with the world frame
        iparams_new = Utilities::rototranslateITensor(
                        tensor,
                        iparams.mass.asFloat,
                        translation,
                        R)
        Utilities::round(iparams_new, 100000)
        return iparams_new
    }
    /*
     * Returns the value of the SDFAST-model property 'BodyToJoint', for the
     * given body. It is the distance vector between the COM of the successor
     * link and the joint origin (which is the same as the link frame origin,
     * in the Kinematics-DSL).
     */
    def private sdfast_successorToJointVector(AbstractLink body, double[][] R)
    {
        val com_pos = body.linkFrameInertiaParams.com
        val original = new Vector3D(0.0, 0.0, 0.0)
        original.x = Utilities::invert(com_pos.x.asFloat)
        original.y = Utilities::invert(com_pos.y.asFloat)
        original.z = Utilities::invert(com_pos.z.asFloat)
        val rotated = Utilities::matrix3x3Mult(R, original)
        rotated.x = sdfast_round(rotated.x)
        rotated.y = sdfast_round(rotated.y)
        rotated.z = sdfast_round(rotated.z)
        return '''«rotated.x» «rotated.y» «rotated.z»'''
    }
    /*
     * Returns the value of the SDFAST-model property 'inbtojoint', for the
     * given body. It is the distance vector between the COM of the predecessor
     * link and the joint origin.
     */
    def private sdfast_predecessorToJointVector(AbstractLink predecessor, Joint joint, double[][] R)
    {
        val joint_pos = Vector3D::convert(joint.refFrame.translation)
        val com_pos   = Vector3D::convert(predecessor.linkFrameInertiaParams.com)
        val diff = new Vector3D(
               (joint_pos.x-com_pos.x),
               (joint_pos.y-com_pos.y),
               (joint_pos.z-com_pos.z))

        var Vector3D rotated = null
        if( R != null) {
            rotated = Utilities::matrix3x3Mult(R, diff)
        } else {
            rotated = diff // no rotation
        }
        rotated.x = sdfast_round(rotated.x)
        rotated.y = sdfast_round(rotated.y)
        rotated.z = sdfast_round(rotated.z)
        return '''«rotated.x» «rotated.y» «rotated.z»'''
    }

    def private sdfast_jointAxis(Joint j, double[][] R)
    {
        val axis = Utilities::jointAxis(j)
        var Vector3D rotated = null
        if( R != null) {
            rotated = Utilities::matrix3x3Mult(R, axis)
        } else {
            rotated = axis // no rotation
        }
        rotated.x = sdfast_round(rotated.x)
        rotated.y = sdfast_round(rotated.y)
        rotated.z = sdfast_round(rotated.z)
        return rotated.x + " " + rotated.y + " " + rotated.z
    }
    def private sdfast_round(double num) {
        return Math.round(num*1000.0)/1000.0
    }

}
