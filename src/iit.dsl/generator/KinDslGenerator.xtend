/*
 * generated by Xtext
 */
package iit.dsl.generator

import iit.dsl.generator.common.TransformsDSLsUtils
import iit.dsl.generator.misc.Misc
import iit.dsl.kinDsl.Robot


import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import iit.dsl.TransSpecsAccessor
import com.google.inject.Guice
import org.eclipse.xtext.parsetree.reconstr.Serializer
import iit.dsl.transspecs.TransSpecsRuntimeModule
import iit.dsl.generator.common.Jacobians


class KinDslGenerator implements IGenerator {
    extension Common common = new Common()
    Misc miscGen = Misc::getInstance()
    MotionDSLDocGenerator motiongen = new MotionDSLDocGenerator()
    TransformsDSLsUtils transformsDSLsUtils = new TransformsDSLsUtils()

    override void doGenerate(Resource resource, IFileSystemAccess fsa) {
        val robot = resource.contents.head as Robot;
        System::out.println()
        val desiredTrasformsAccessor = new TransSpecsAccessor()
        val desired = desiredTrasformsAccessor.getDesiredTransforms(robot)

        //fsa.generateFile(robot.name+".urdf", miscGen.URDF_ROS_model(robot))
        //fsa.generateFile(robot.name+".sd", miscGen.SDFAST_model(robot))
        fsa.generateFile(MotionDSLDocGenerator::fileName(robot), motiongen.documentContent(robot))
        fsa.generateFile(
            TransformsDSLsUtils::documentDefaultName_TransformsDSL(robot),
            transformsDSLsUtils.coordinateTransformsDSLDoc(robot, desired))
//        //testUtilities()
//        testJacobianUtils(robot)
    }




    def testITensorRotation(Robot hyl) {
        val hip = hyl.getLinkByName("hip")
        val original = hip.inertiaParams;
        val comFrame = hip.frames.get(0);
        val transf   = Utilities::rototranslate(original,
            comFrame.transform.translation.x.asFloat,
            comFrame.transform.translation.y.asFloat,
            comFrame.transform.translation.z.asFloat,
            comFrame.transform.rotation.x.asFloat,  //(-Math::PI/5) as float,//
            comFrame.transform.rotation.y.asFloat,  //(-Math::PI/6) as float,//
            comFrame.transform.rotation.z.asFloat, //(-Math::PI/3) as float)//
            false);
        System::out.println(transf.mass)
        System::out.println('''«transf.com.x.asFloat»  «transf.com.y.asFloat»  «transf.com.z.asFloat»''')
        System::out.println('''«transf.ix»  «transf.iy»  «transf.iz»  «transf.ixy»  «transf.ixz»  «transf.iyz»''')
        //System::out.println(transf.mass)
    }


    def test_getJoint(Robot robot) {
        System::out.println('''
        «FOR link : robot.links»
        Parent «link.parent.name», child: «link.name»  -  Joint: «getJoint(link.parent, link).name»
        «ENDFOR»'''.toString() );
    }

    def test_jointFromVariableName(Robot robot) {
        System::out.println('''
        «FOR joint : robot.joints»
        Joint «joint.name», variable: «joint.variableName», joint again: «(robot.getJointFromVariableName(joint.variableName.toString())).name»
        «ENDFOR»'''.toString() );
    }
    /*
    '''
        «FOR link : robot.abstractLinks»
            «FOR link2 : robot.abstractLinks»
                «val chain = common.buildChain(link, link2)»
                «link.name» - «link2.name»   :   «FOR AbstractLink el : chain» «el.name»«ENDFOR»
            «ENDFOR»
        «ENDFOR»

    '''
    //*/
    /*
    var AbstractLink found;
        for(AbstractLink l: robot.abstractLinks) {
            found = common.getLinkByName(robot, l.name)
            if(! found.equals(l)) {
                throw new RuntimeException("test failed!")
            }
        }
    //throw new RuntimeException("OK!!")
    //*/
    /*
    '''
        «FOR link : robot.abstractLinks»
        Link «link.name» moved by  «link.connectingJoint»
        «ENDFOR»
        «FOR link : robot.links»
        Link «link.name» connected from  «link.parent.name»  via  «link.connectingJoint.name»
        «ENDFOR»
        «FOR joint : robot.joints»
        Joint «joint.name» connecting  «joint.successorLink.name»
        «ENDFOR»
    '''
    //*/
    /*
    '''
        «FOR link : robot.links»
        Link «link.name» connected from  «link.parent.name»  via  «link.connectingJoint.name»
        «ENDFOR»
        «FOR joint : robot.joints»
        Joint «joint.name» connecting  «joint.successorLink.name»
        «ENDFOR»
    '''
    //*/


    def temp(Resource resource) '''
        «FOR r : resource.contents»
        «r.eClass.name»
        «ENDFOR»'''

    def testUtilities() {
        val rx = Math::random() + Math::random() + Math::random()
        val ry = -Math::random()
        val rz = -Math::random()
        System::out.println('''«rx»  «ry»  «rz»''')
        val mx = Utilities::rotated_X_original(rx, ry, rz)
        val double[] foo = Utilities::get_rxryrz(mx)
        System::out.println('''«foo.get(0)»  «foo.get(1)»  «foo.get(2)»''')
    }

    def testJacobianUtils(Robot robot) {
        val desiredTrasformsAccessor = new TransSpecsAccessor()
        val desJacs = desiredTrasformsAccessor.getDesiredTransforms(robot)

        val jacsList = Jacobians::getJacobiansList(robot, desJacs)
        var iit.dsl.transspecs.transSpecs.TransformsList allTransforms =
            desJacs.transforms
        for (J : jacsList ) {
            allTransforms = iit::dsl::transspecs::utils::Utils::merge(
                allTransforms,
                Jacobians::getRequiredTransformsSpecs(J) )
        }
        val allTransformsModel = iit::dsl::transspecs::utils::Utils::createModel(allTransforms)
        System::out.println()
        for (spec : allTransformsModel.transforms.specs) {
            System::out.println("base: " + spec.base.name + "  target: " + spec.target.name)
        }
    }

   def testDesiredTransformsAccessor() {
        val accessor = new TransSpecsAccessor
        val model1 = accessor.getModel(dtdsl_doc1.toString)
        val model2 = accessor.getModel(dtdsl_doc2.toString)

        val injector = Guice::createInjector(new TransSpecsRuntimeModule());
        val serializer = injector.getInstance(typeof(Serializer));

        val merged = iit::dsl::transspecs::utils::Utils::merge(model1, model2)

        System::out.println(serializer.serialize(merged.framesList))
        //System::out.println(serializer.serialize(merged.transforms))
        for(t : merged.transforms.specs) {
            System::out.println(t.base.name + " " + t.target.name)
        }
    }

    val dtdsl_doc1 = '''
        Robot doc1

        Frames {
        f1,f2,f4
        }

        Transforms {
            base=f1, target=f2
            base=f2, target=f1
            base=f2, target=f4
        }

    '''

    val dtdsl_doc2 = '''
        Robot doc2

        Frames {
        f1,f2,f3
        }

        Transforms {
            base=f1, target=f2
            base=f2, target=f3
        }

    '''


}
