«IMPORT iit::dsl::kinDsl»

«EXTENSION templates::common»
«EXTENSION templates::my_eigen_plain»

«DEFINE main FOR Robot»
«REM»
======================================
HEADER FILE
======================================«ENDREM»
«FILE this.baseFileName() + ".h"»

#ifndef IIT_RBD_«this.baseFileName().toUpperCase()»_H_
#define IIT_RBD_«this.baseFileName().toUpperCase()»_H_

#include <Eigen/Dense>
#include <iit/rbd/rbd.h>
#include <iit/rbd/CoordinateTransform.h>
#include <iit/rbd/InertiaMatrix.h>
#include <iit/rbd/MotionSubspaceMx.h>
#include <iit/rbd/utils.h>

namespace iit {
namespace «name» {

typedef Eigen::Matrix<double, «joints.size», 1> Column«joints.size»d;
typedef Column«joints.size»d StateVector;

typedef iit::rbd::InertiaMatrixDense InertiaMatrix;
typedef iit::rbd::CoordinateTransformDense CoordinateTransform;
typedef iit::rbd::MotionSubspaceMxSparse SubspaceMx;
typedef iit::rbd::SparseColumnd JointVelocity;
typedef iit::rbd::Column6d MotionVector;
typedef iit::rbd::Column6d ForceVector;


class «className()» {
public:
    Dynamics();
    void id(const StateVector& q, const StateVector& qd, const StateVector& qdd, StateVector& torques);
public:
    iit::rbd::SparseColumnd gravity;

private:
    iit::rbd::Matrix66d spareMx; // support variable
    CoordinateTransform XJ;
    JointVelocity vJ;
«FOREACH joints AS j-»
    // Joint '«j.name»' :
    SubspaceMx «subspaceMxName(j)»;
    CoordinateTransform «coordTransformName(j)»;
«ENDFOREACH»
«FOREACH links AS l-»
    // Link '«l.name»' :
    InertiaMatrix «inertiaMxName(l)»;
    CoordinateTransform «childToParentMxName(l)»;
    MotionVector «velocityName(l)»;
    MotionVector «accelerationName(l)»;
    ForceVector  «forceName(l)»;
«ENDFOREACH»

};

}
}

#endif
«ENDFILE»


«REM»
======================================
File .cpp
======================================«ENDREM»
«FILE this.name + "_main.cpp"»
#include <cmath>
#include <iostream>
using namespace std;

#include "«this.baseFileName()».h"

using namespace iit::«name»;
using namespace iit::rbd;

int main(int argc, char** argv) {
    StateVector q, qd, qdd, tau;
«FOREACH joints AS j-»
    q(«j.getID()-1»)   = std::atof(argv[«j.getID()»]);
    qd(«j.getID()-1»)  = std::atof(argv[«j.getID() + joints.size»]);
    qdd(«j.getID()-1») = std::atof(argv[«j.getID() + joints.size + joints.size»]);
«ENDFOREACH»

    «className()» foo;

    foo.id(q,qd,qdd,tau);
    std::cout << tau << std::endl;
    return 0;
}

«ENDFILE»


«FILE this.baseFileName() + ".cpp"»
#include <cmath>
#include <iostream>
using namespace std;

#include "«this.baseFileName()».h"

using namespace iit::«name»;
using namespace iit::rbd;

«className()»::«className()»() {
#ifndef EIGEN_NO_DEBUG
    std::cout << "Robot «name», «className()»::«className()»()" << std::endl;
    std::cout << "Compiled with Eigen debug active" << std::endl;
#endif
    gravity.resize(6);
    gravity.insert(5) = 9.81;
    vJ.resize(6);

«FOREACH joints AS j-»
    «coordTransformName(j)».fillAsMotionTransform(
        Vector3d(«j.refFrame.translation.items.toString(", ")»),
        «j.refFrame.rotation.items.toString(", ")»
        );
«ENDFOREACH»
«FOREACH joints AS j-»
    «EXPAND jointSubspaceMx FOR j»
«ENDFOREACH»
«FOREACH links AS l-»
    «inertiaMxName(l)».fill(«l.inertiaParams.mass», Vector3d(«l.inertiaParams.com.items.toString(", ")»),
              Utils::buildInertiaTensor(«l.inertiaParams.ix»,«l.inertiaParams.iy»,«l.inertiaParams.iz»,«l.inertiaParams.ixy»,«l.inertiaParams.ixz»,«l.inertiaParams.iyz»));
«ENDFOREACH»
}

void Dynamics::id(const StateVector& q, const StateVector& qd, const StateVector& qdd, StateVector& torques) {
«LET links.sortBy( link | link.getID()) AS sortedLinks»
«FOREACH sortedLinks AS l-»
    «EXPAND algoFirstPass FOR l-»
«ENDFOREACH»
«FOREACH sortedLinks.reverse() AS l-»
    «EXPAND algoSecondPass FOR l-»
«ENDFOREACH»
«ENDLET»
} 
«ENDFILE»


«FILE this.name + "_mainforSL.cpp"»
#include <iostream>
#include <fstream>
#include <ctime>

#include "«name»_dynamics.h"

#include "SL.h"
#include "SL_kinematics.h"
#include "SL_dynamics.h"

#include "SL_user.h"

using namespace std;
using namespace iit::«name»;

static void fillState(StateVector& q, StateVector& qd, StateVector& qdd, SL_DJstate* desiredState);

/* This main is supposed to be used to test the inverse kinematics routines */
int main(int argc, char**argv)
{
    int numOfIterations =0;//= std::atoi(argv[1]);
    int numOfTests = std::atoi(argv[1]);
    double sl[numOfTests];
    double me[numOfTests];

    double t0, duration, sl_total, my_total;
    sl_total = 0;
    my_total = 0;

    iit::«name»::StateVector q, qd, qdd, tau;
    iit::«name»::Dynamics myDynamics;

    int t=0,i=0;

    SL_Jstate currentState[N_ROBOT_DOFS];
    SL_DJstate desiredState[N_ROBOT_DOFS];
    SL_endeff endeffector[N_ROBOT_ENDEFFECTORS];
    SL_Cstate basePosition;
    SL_quat baseOrient;

    init_kinematics();
    if( ! init_dynamics() ) {
        cerr << "Error in init_dynamics()" << endl;
        exit(-1);
    }

    for(i=0; i<N_ROBOT_DOFS; i++) {
        currentState[i].th   = 0;
        currentState[i].thd  = 0;
        currentState[i].thdd = 0;

        desiredState[i].th   = 0;
        desiredState[i].thd  = 0;
        desiredState[i].thdd = 0;

        desiredState[i].uff  = 0;
        desiredState[i].uex  = 0;
    }

    endeffector[LF_LEG].m = 0; // zero mass -> no endeffector
    for(i=0; i<=N_CART; i++) {
        basePosition.x[i]   = 0;
        basePosition.xd[i]  = 0;
        basePosition.xdd[i] = 0;

        endeffector[LF_LEG].mcm[i] = 0;
        endeffector[LF_LEG].cf[i]  = 0;
        endeffector[LF_LEG].ct[i]  = 0;
        endeffector[LF_LEG].x[i]   = 0;
        endeffector[LF_LEG].a[i]   = 0;
    }
    baseOrient.q[_Q0_] = 1;
    baseOrient.q[_Q1_] = 0;
    baseOrient.q[_Q2_] = 0;
    baseOrient.q[_Q3_] = 0;


    std::srand(std::time(NULL)); // initialize random number generator


//    // Prints numerical results, for comparison
//    fillState(q, qd, qdd, desiredState);
//    SL_InvDynNE(NULL, desiredState, endeffector, &basePosition, &baseOrient);
//    myDynamics.id(q, qd, qdd, tau);
//
//    printf("%f\n %f\n %f\n %f\n \n", desiredState[SLIDER_Z].uff,
//            desiredState[LF_HAA].uff, desiredState[LF_HFE].uff, desiredState[LF_KFE].uff);
//    cout << tau << endl;
//    return 1;

    ofstream out("«name»_testdata.m");
    out << "«name»_test.iterations = [";

    for(t=0; t<numOfTests; t++) {
        sl_total = 0;
        my_total = 0;
        numOfIterations = std::pow(10,t+1);
        out << numOfIterations << " ";

        for(i=0; i<numOfIterations; i++) {
            fillState(q, qd, qdd, desiredState);

            t0 = std::clock();
            SL_InvDynNE(NULL, desiredState, endeffector, &basePosition, &baseOrient);
            duration = std::clock() - t0;
            sl_total += duration;

            t0 = std::clock();
            myDynamics.id(q, qd, qdd, tau);
            duration = std::clock() - t0;
            my_total += duration;
        }
        sl[t] = sl_total/CLOCKS_PER_SEC;
        me[t] = my_total/CLOCKS_PER_SEC;
    }


    out << "];" << endl;
    // SL times
    out << "«name»_test.sl = [";
    for(t=0; t<numOfTests; t++) {
        out << sl[t] << " ";
    }
    out << "];" << endl;
    // My times
    out << "«name»_test.me = [";
    for(t=0; t<numOfTests; t++) {
        out << me[t] << " ";
    }
    out << "];" << endl;

    for(t=0; t<numOfTests; t++) {
        cout << "SL: " << sl[t] << "\t Me: " << me[t] << endl;
    }

    return TRUE;
}


void fillState(StateVector& q, StateVector& qd, StateVector& qdd, SL_DJstate* desiredState) {
    static const double max = 12.3;
«FOREACH joints AS j-»
    q(«j.getID()-1»)   = ( ((double)std::rand()) / RAND_MAX) * max;
    qd(«j.getID()-1»)  = ( ((double)std::rand()) / RAND_MAX) * max;
    qdd(«j.getID()-1») = ( ((double)std::rand()) / RAND_MAX) * max;
«ENDFOREACH»
    //TODO this part needs manual adaption!!
    desiredState[SLIDER_Z].th   = q(0);
    desiredState[SLIDER_Z].thd  = qd(0);
    desiredState[SLIDER_Z].thdd = qdd(0);
    desiredState[LF_HAA].th   = q(1);
    desiredState[LF_HAA].thd  = qd(1);
    desiredState[LF_HAA].thdd = qdd(1);
    desiredState[LF_HFE].th   = q(2);
    desiredState[LF_HFE].thd  = qd(2);
    desiredState[LF_HFE].thdd = qdd(2);
    desiredState[LF_KFE].th   = q(3);
    desiredState[LF_KFE].thd  = qd(3);
    desiredState[LF_KFE].thdd = qdd(3);
}

«ENDFILE»

«ENDDEFINE»«REM» Main «ENDREM»





«REM»
======================================
Helper defines
======================================«ENDREM»

«REM»
Motion subspace matrix, for each joint
-------------------------------------- «ENDREM»
«DEFINE jointSubspaceMx FOR Joint-»
    «ERROR "No subspace matrix defined for an abstract joint"»
«ENDDEFINE»
«DEFINE jointSubspaceMx FOR PrismaticJoint-»
    «subspaceMxName()».resize(6);
    «subspaceMxName()».insert(5) = 1.0;
«ENDDEFINE»
«DEFINE jointSubspaceMx FOR RevoluteJoint-»
    «subspaceMxName()».resize(6);
    «subspaceMxName()».insert(2) = 1.0;
«ENDDEFINE»


«REM»
A step of the FIRST pass of the inverse dynamics algorithm, for each link
------------------------------------------------------------------------- «ENDREM»
«DEFINE algoFirstPass FOR AbstractLink-»
    «ERROR "This is just a place holder"»
«ENDDEFINE»
«DEFINE algoFirstPass FOR FloatingRobotBase-»
    //TODO TODO TODO
«ENDDEFINE»
«DEFINE algoFirstPass FOR FixedRobotBase-»
«ENDDEFINE»
«DEFINE algoFirstPass FOR Link-»
    // First pass, link '«name»'
    «LET getParent() AS parentLink-»
    «REM»The following obscure line gets the joint which connects the parent to this child «ENDREM»
    «LET (parentLink.childrenList.children.select(child | child.link == this)).first().joint AS myJoint-»
    «EXPAND jCalc FOR myJoint-»
    «childToParentMxName()» = XJ * «myJoint.coordTransformName()»;
    «IF parentLink.getID() == 0»
    «velocityName()» = «myJoint.subspaceMxName()» * qd(«myJoint.getID()-1»); // «velocityName()» = vJ, for the first link of a fixed base robot
    «accelerationName()» = («childToParentMxName()» * gravity) + («myJoint.subspaceMxName()» * qdd(«myJoint.getID()-1»)).toDense();
    Utils::fillAsForceCrossProductMx(«velocityName()», spareMx); // this could be optimized..
    «forceName()» = «inertiaMxName()» * «accelerationName()» + (spareMx * «inertiaMxName()» * «velocityName()»);
    «ELSE»
    vJ = «myJoint.subspaceMxName()» * qd(«myJoint.getID()-1»);
    «velocityName()» = («childToParentMxName()» * «parentLink.velocityName()») + vJ.toDense();
    Utils::fillAsMotionCrossProductMx(«velocityName()», spareMx); // this could be optimized..
    «accelerationName()» = («childToParentMxName()» * «parentLink.accelerationName()-») +
             («myJoint.subspaceMxName()» * qdd(«myJoint.getID()-1-»)).toDense() +
             (spareMx * vJ);
    «forceName()» = «inertiaMxName()» * «accelerationName()» + (-spareMx.transpose() * «inertiaMxName()» * «velocityName()»);
    «ENDIF»
    «ENDLET»
    «ENDLET»
«ENDDEFINE»
«REM»
A step of the SECOND pass of the inverse dynamics algorithm, for each link
«ENDREM»
«DEFINE algoSecondPass FOR AbstractLink-»
    «ERROR "This is just a place holder"»
«ENDDEFINE»
«DEFINE algoSecondPass FOR FloatingRobotBase-»
    //TODO TODO TODO
«ENDDEFINE»
«DEFINE algoSecondPass FOR FixedRobotBase-»
«ENDDEFINE»
«DEFINE algoSecondPass FOR Link-»
    // Second pass, link '«name»'
    «LET getParent() AS parentLink-»
    «REM»The following obscure line gets the joint which connects the parent to this child «ENDREM»
    «LET (parentLink.childrenList.children.select(child | child.link == this)).first().joint AS myJoint-»
    torques(«getID()-1») = «myJoint.subspaceMxName()».transpose().dot(«forceName()»);
    «IF parentLink.getID() != 0»
    // Compute the contribution on the force acting on the parent link
    «parentLink.forceName()» = «parentLink.forceName()» + «childToParentMxName()».transpose() * «forceName()»;
    «ENDIF»
    «ENDLET»
    «ENDLET»
«ENDDEFINE»

«REM»
The motion transform that depends on the state of the joint.
This can be optimized removing the call to the fill function
«ENDREM»
«DEFINE jCalc FOR Joint-»
    «ERROR "This is just a place holder"»
«ENDDEFINE»
«DEFINE jCalc FOR PrismaticJoint-»
    XJ.fillAsMotionTransform(Vector3d(0.0, 0.0, q(«getID()-1»)), 0.0, 0.0, 0.0);
«ENDDEFINE»
«DEFINE jCalc FOR RevoluteJoint-»
    XJ.fillAsMotionTransform(Vector3d(0.0, 0.0, 0.0), 0.0, 0.0, q(«getID()-1»));
«ENDDEFINE»

