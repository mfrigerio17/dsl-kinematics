«IMPORT iit::dsl::kinDsl»

«EXTENSION templates::common»
«EXTENSION templates::my_eigen_plain»

«DEFINE main FOR Robot»
«REM»
======================================
File .h
======================================«ENDREM»
«FILE this.baseFileName() + ".h"»

#ifndef IIT_RBD_«this.baseFileName().toUpperCase()»_H_
#define IIT_RBD_«this.baseFileName().toUpperCase()»_H_

#include <Eigen/Dense>
#include <iit/rbd/rbd.h>
#include <iit/rbd/CoordinateTransform.h>
#include <iit/rbd/InertiaMatrix.h>
#include <iit/rbd/MotionSubspaceMx.h>
#include <iit/rbd/utils.h>

namespace iit {
namespace «name» {

typedef Eigen::Matrix<double, «joints.size», 1> Column«joints.size»d;
typedef Column«joints.size»d StateVector;

typedef iit::rbd::InertiaMatrixDense InertiaMatrix;
typedef iit::rbd::CoordinateTransformDense CoordinateTransform;
typedef iit::rbd::MotionSubspaceMxSparse SubspaceMx;
typedef iit::rbd::SparseColumnd JointVelocity;
typedef iit::rbd::Column6d MotionVector;


class «className()» {
public:
    Dynamics();
    StateVector id(const StateVector& q, const StateVector& qd, const StateVector& qdd);
public:
     iit::rbd::SparseColumnd gravity;

private:
     CoordinateTransform XJ;
     JointVelocity vJ;
     iit::rbd::Matrix66d spareMx;
«FOREACH joints AS j-»
     CoordinateTransform «coordTransformName(j)»;
«ENDFOREACH»

«FOREACH joints AS j-»
     SubspaceMx «subspaceMxName(j)»;
«ENDFOREACH»

«FOREACH links AS l-»
     InertiaMatrix «inertiaMxName(l)»;
     CoordinateTransform «childToParentMxName(l)»;
     MotionVector «velocityName(l)»;
     MotionVector «accelerationName(l)»;
«ENDFOREACH»

};

}
}

#endif
«ENDFILE»


«REM»
======================================
File .cpp
======================================«ENDREM»
«FILE this.baseFileName() + ".cpp"»
#include <cmath>
#include <iostream>
using namespace std;

#include "«this.baseFileName()».h"

using namespace iit::«name»;
using namespace iit::rbd;

int main() {
    StateVector q, qd, qdd;
    q.setOnes();
    qd.setOnes();
    qdd.setOnes();

    «className()» foo;

    foo.id(q,qd,qdd*3);
    return 0;
}

«className()»::«className()»() {
    gravity.resize(6);
    gravity.insert(5) = 9.81;
    vJ.resize(6);

«FOREACH joints AS j-»
    «coordTransformName(j)».fillAsMotionTransform(
        Vector3d(«j.refFrame.translation.items.toString(", ")»),
        «j.refFrame.rotation.items.toString(", ")»
        );
«ENDFOREACH»
«FOREACH joints AS j-»
    «EXPAND jointSubspaceMx FOR j»
«ENDFOREACH»
«FOREACH links AS l-»
    «inertiaMxName(l)».fill(«l.inertiaParams.mass», Vector3d(«l.inertiaParams.com.items.toString(", ")»),
              Utils::buildInertiaTensor(«l.inertiaParams.ix»,«l.inertiaParams.iy»,«l.inertiaParams.iz»,«l.inertiaParams.ixy»,«l.inertiaParams.ixz»,«l.inertiaParams.iyz»));
«ENDFOREACH»
}

StateVector Dynamics::id(const StateVector& q, const StateVector& qd, const StateVector& qdd) {
«FOREACH links AS l-»
    «EXPAND algoStep FOR l-»
«ENDFOREACH»
} 
«ENDFILE»
«ENDDEFINE»


«REM»
======================================
Helper defines
======================================«ENDREM»

«REM»
Motion subspace matrix, for each joint
«ENDREM»
«DEFINE jointSubspaceMx FOR Joint-»
    «ERROR "No subspace matrix defined for an abstract joint"»
«ENDDEFINE»
«DEFINE jointSubspaceMx FOR PrismaticJoint-»
    «subspaceMxName()».resize(6);
    «subspaceMxName()».insert(5) = 1.0;
«ENDDEFINE»
«DEFINE jointSubspaceMx FOR RevoluteJoint-»
    «subspaceMxName()».resize(6);
    «subspaceMxName()».insert(2) = 1.0;
«ENDDEFINE»


«REM»
A step of the forward pass of the inverse dynamics algorithm, for each link
«ENDREM»
«DEFINE algoStep FOR AbstractLink-»
    «ERROR "This is just a place holder"»
«ENDDEFINE»
«DEFINE algoStep FOR FloatingRobotBase-»
    //TODO TODO TODO
«ENDDEFINE»
«DEFINE algoStep FOR FixedRobotBase-»
«ENDDEFINE»
«DEFINE algoStep FOR Link-»
    «LET this.getParent() AS parentLink»
    «REM»The following obscure line gets the joint which connects the parent to this child «ENDREM»
    «LET (parentLink.childrenList.children.select(child | child.link == this)).first().joint AS myJoint»
    «EXPAND jCalc FOR myJoint»
    «this.childToParentMxName()» = XJ * «myJoint.coordTransformName()»;
    «IF parentLink.getID() == 0»
    «this.velocityName()» = «myJoint.subspaceMxName()» * qd(«myJoint.getID()-1»); // «this.velocityName()» = vJ, for the first link
    «this.accelerationName()» = («this.childToParentMxName()» * gravity) + («myJoint.subspaceMxName()» * qdd(«myJoint.getID()-1»)).toDense();
    «ELSE»
    vJ = «myJoint.subspaceMxName()» * qd(«myJoint.getID()-1»);
    «this.velocityName()» = («this.childToParentMxName()» * «parentLink.velocityName()») + vJ.toDense();
    Utils::fillAsMotionCrossProductMx(«this.velocityName()», spareMx);
    «this.accelerationName()» = («this.childToParentMxName()» * «parentLink.accelerationName()-») +
             («myJoint.subspaceMxName()» * qdd(«myJoint.getID()-1-»)).toDense() +
             (spareMx * vJ);
    «ENDIF»
    
    
    «ENDLET»
    «ENDLET»
«ENDDEFINE»

«REM»
The motion transform that depends on the state of the joint.
This can be optimized removing the call to the fill function
«ENDREM»
«DEFINE jCalc FOR Joint-»
    «ERROR "This is just a place holder"»
«ENDDEFINE»
«DEFINE jCalc FOR PrismaticJoint-»
    XJ.fillAsMotionTransform(Vector3d(0.0, 0.0, q(«getID()-1»)), 0.0, 0.0, 0.0);
«ENDDEFINE»
«DEFINE jCalc FOR RevoluteJoint-»
    XJ.fillAsMotionTransform(Vector3d(0.0, 0.0, 0.0), 0.0, 0.0, q(«getID()-1»));
«ENDDEFINE»

