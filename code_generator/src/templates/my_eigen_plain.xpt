«IMPORT iit::dsl::kinDsl»

«EXTENSION templates::common»
«EXTENSION templates::my_eigen_plain»

«DEFINE main FOR Robot»
«REM»
======================================
HEADER FILE
======================================«ENDREM»
«FILE this.baseFileName() + ".h"»

#ifndef IIT_RBD_«this.baseFileName().toUpperCase()»_H_
#define IIT_RBD_«this.baseFileName().toUpperCase()»_H_

#include <Eigen/Dense>
#include <iit/rbd/rbd.h>
#include <iit/rbd/CoordinateTransform.h>
#include <iit/rbd/InertiaMatrix.h>
#include <iit/rbd/MotionSubspaceMx.h>
#include <iit/rbd/utils.h>

namespace iit {
namespace «name» {

typedef Eigen::Matrix<double, «joints.size», 1> Column«joints.size»d;
typedef Column«joints.size»d StateVector;

typedef iit::rbd::InertiaMatrixDense InertiaMatrix;
typedef iit::rbd::CoordinateTransformDense CoordinateTransform;
typedef iit::rbd::MotionSubspaceMxSparse SubspaceMx;
typedef iit::rbd::SparseColumnd JointVelocity;
typedef iit::rbd::Column6d MotionVector;
typedef iit::rbd::Column6d ForceVector;


class «className()» {
public:
    Dynamics();
    void id(const StateVector& q, const StateVector& qd, const StateVector& qdd, StateVector& torques);
public:
    iit::rbd::SparseColumnd gravity;

private:
    iit::rbd::Matrix66d spareMx; // support variable
    CoordinateTransform XJ;
    JointVelocity vJ;
«FOREACH joints AS j-»
    // Joint '«j.name»' :
    SubspaceMx «subspaceMxName(j)»;
    CoordinateTransform «coordTransformName(j)»;
«ENDFOREACH»
«FOREACH links AS l-»
    // Link '«l.name»' :
    InertiaMatrix «inertiaMxName(l)»;
    CoordinateTransform «childToParentMxName(l)»;
    MotionVector «velocityName(l)»;
    MotionVector «accelerationName(l)»;
    ForceVector  «forceName(l)»;
«ENDFOREACH»

};

}
}

#endif
«ENDFILE»


«REM»
======================================
File .cpp
======================================«ENDREM»
«FILE this.name + "_main.cpp"»
#include <cmath>
#include <iostream>
using namespace std;

#include "«this.baseFileName()».h"

using namespace iit::«name»;
using namespace iit::rbd;

int main(int argc, char** argv) {
    StateVector q, qd, qdd, tau;
«FOREACH joints AS j-»
    q(«j.getID()-1»)   = std::atof(argv[«j.getID()»]);
    qd(«j.getID()-1»)  = std::atof(argv[«j.getID() + joints.size»]);
    qdd(«j.getID()-1») = std::atof(argv[«j.getID() + joints.size + joints.size»]);
«ENDFOREACH»

    «className()» foo;

    foo.id(q,qd,qdd,tau);
    std::cout << tau << std::endl;
    return 0;
}

«ENDFILE»


«FILE this.baseFileName() + ".cpp"»
#include <cmath>
#include <iostream>
using namespace std;

#include "«this.baseFileName()».h"

using namespace iit::«name»;
using namespace iit::rbd;

«className()»::«className()»() {
#ifndef EIGEN_NO_DEBUG
    std::cout << "Robot «name», «className()»::«className()»()" << std::endl;
    std::cout << "Compiled with Eigen debug active" << std::endl;
#endif
    gravity.resize(6);
    gravity.insert(5) = 9.81;
    vJ.resize(6);

«FOREACH joints AS j-»
    «coordTransformName(j)».fillAsMotionTransform(
        Vector3d(«j.refFrame.translation.items.toString(", ")»),
        «j.refFrame.rotation.items.toString(", ")»
        );
«ENDFOREACH»
«FOREACH joints AS j-»
    «EXPAND jointSubspaceMx FOR j»
«ENDFOREACH»
«FOREACH links AS l-»
    «inertiaMxName(l)».fill(«l.inertiaParams.mass», Vector3d(«l.inertiaParams.com.items.toString(", ")»),
              Utils::buildInertiaTensor(«l.inertiaParams.ix»,«l.inertiaParams.iy»,«l.inertiaParams.iz»,«l.inertiaParams.ixy»,«l.inertiaParams.ixz»,«l.inertiaParams.iyz»));
«ENDFOREACH»
}

void Dynamics::id(const StateVector& q, const StateVector& qd, const StateVector& qdd, StateVector& torques) {
«LET links.sortBy( link | link.getID()) AS sortedLinks»
«FOREACH sortedLinks AS l-»
    «EXPAND algoFirstPass FOR l-»
«ENDFOREACH»
«FOREACH sortedLinks.reverse() AS l-»
    «EXPAND algoSecondPass FOR l-»
«ENDFOREACH»
«ENDLET»
} 
«ENDFILE»
«ENDDEFINE»


«REM»
======================================
Helper defines
======================================«ENDREM»

«REM»
Motion subspace matrix, for each joint
-------------------------------------- «ENDREM»
«DEFINE jointSubspaceMx FOR Joint-»
    «ERROR "No subspace matrix defined for an abstract joint"»
«ENDDEFINE»
«DEFINE jointSubspaceMx FOR PrismaticJoint-»
    «subspaceMxName()».resize(6);
    «subspaceMxName()».insert(5) = 1.0;
«ENDDEFINE»
«DEFINE jointSubspaceMx FOR RevoluteJoint-»
    «subspaceMxName()».resize(6);
    «subspaceMxName()».insert(2) = 1.0;
«ENDDEFINE»


«REM»
A step of the FIRST pass of the inverse dynamics algorithm, for each link
------------------------------------------------------------------------- «ENDREM»
«DEFINE algoFirstPass FOR AbstractLink-»
    «ERROR "This is just a place holder"»
«ENDDEFINE»
«DEFINE algoFirstPass FOR FloatingRobotBase-»
    //TODO TODO TODO
«ENDDEFINE»
«DEFINE algoFirstPass FOR FixedRobotBase-»
«ENDDEFINE»
«DEFINE algoFirstPass FOR Link-»
    // First pass, link '«name»'
    «LET getParent() AS parentLink-»
    «REM»The following obscure line gets the joint which connects the parent to this child «ENDREM»
    «LET (parentLink.childrenList.children.select(child | child.link == this)).first().joint AS myJoint-»
    «EXPAND jCalc FOR myJoint-»
    «childToParentMxName()» = XJ * «myJoint.coordTransformName()»;
    «IF parentLink.getID() == 0»
    «velocityName()» = «myJoint.subspaceMxName()» * qd(«myJoint.getID()-1»); // «velocityName()» = vJ, for the first link of a fixed base robot
    «accelerationName()» = («childToParentMxName()» * gravity) + («myJoint.subspaceMxName()» * qdd(«myJoint.getID()-1»)).toDense();
    Utils::fillAsForceCrossProductMx(«velocityName()», spareMx); // this could be optimized..
    «forceName()» = «inertiaMxName()» * «accelerationName()» + (spareMx * «inertiaMxName()» * «velocityName()»);
    «ELSE»
    vJ = «myJoint.subspaceMxName()» * qd(«myJoint.getID()-1»);
    «velocityName()» = («childToParentMxName()» * «parentLink.velocityName()») + vJ.toDense();
    Utils::fillAsMotionCrossProductMx(«velocityName()», spareMx); // this could be optimized..
    «accelerationName()» = («childToParentMxName()» * «parentLink.accelerationName()-») +
             («myJoint.subspaceMxName()» * qdd(«myJoint.getID()-1-»)).toDense() +
             (spareMx * vJ);
    «forceName()» = «inertiaMxName()» * «accelerationName()» + (-spareMx.transpose() * «inertiaMxName()» * «velocityName()»);
    «ENDIF»
    «ENDLET»
    «ENDLET»
«ENDDEFINE»
«REM»
A step of the SECOND pass of the inverse dynamics algorithm, for each link
«ENDREM»
«DEFINE algoSecondPass FOR AbstractLink-»
    «ERROR "This is just a place holder"»
«ENDDEFINE»
«DEFINE algoSecondPass FOR FloatingRobotBase-»
    //TODO TODO TODO
«ENDDEFINE»
«DEFINE algoSecondPass FOR FixedRobotBase-»
«ENDDEFINE»
«DEFINE algoSecondPass FOR Link-»
    // Second pass, link '«name»'
    «LET getParent() AS parentLink-»
    «REM»The following obscure line gets the joint which connects the parent to this child «ENDREM»
    «LET (parentLink.childrenList.children.select(child | child.link == this)).first().joint AS myJoint-»
    torques(«getID()-1») = «myJoint.subspaceMxName()».transpose().dot(«forceName()»);
    «IF parentLink.getID() != 0»
    // Compute the contribution on the force acting on the parent link
    «parentLink.forceName()» = «parentLink.forceName()» + «childToParentMxName()».transpose() * «forceName()»;
    «ENDIF»
    «ENDLET»
    «ENDLET»
«ENDDEFINE»

«REM»
The motion transform that depends on the state of the joint.
This can be optimized removing the call to the fill function
«ENDREM»
«DEFINE jCalc FOR Joint-»
    «ERROR "This is just a place holder"»
«ENDDEFINE»
«DEFINE jCalc FOR PrismaticJoint-»
    XJ.fillAsMotionTransform(Vector3d(0.0, 0.0, q(«getID()-1»)), 0.0, 0.0, 0.0);
«ENDDEFINE»
«DEFINE jCalc FOR RevoluteJoint-»
    XJ.fillAsMotionTransform(Vector3d(0.0, 0.0, 0.0), 0.0, 0.0, q(«getID()-1»));
«ENDDEFINE»

