import iit::dsl::kinDsl;

inertiaMxName(Link this) :
    this.name + "_Imx"
;

coordTransformName(Joint this) :
    this.name + "_X"
;

subspaceMxName(Joint this) :
    this.name + "_S"
;

childToParentMxName(Link child) :
    child.name + "_X_" + child.getParent().name
;

velocityName(AbstractLink this) :
    this.name + "_v";
accelerationName(AbstractLink this) :
    this.name + "_a";
forceName(AbstractLink this) :
    this.name + "_f";

Boolean isFloating(RobotBase this) :
    false
;
Boolean isFloating(FloatingRobotBase this) :
    true
;

movingBodiesCount(Robot this) :
    if this.base.isFloating() then
        this.links.size + 1
    else
        this.links.size
;


create List[AbstractLink] abstractLinks(Robot robot) :
    this.add(robot.base) ->
    this.addAll(robot.links)
;

/* Returns whether the ChildrenList contains the specified link */
Boolean contains(ChildrenList this, AbstractLink link) :
    (this.children.select(child | child.link == link)).size != 0
;
/* Returns whether the ChildrenList contains the specified joint */
Boolean contains(ChildrenList this, Joint joint) :
    (this.children.select(child | child.joint == joint)).size != 0
;

AbstractLink getParent(AbstractLink link) :
    abstractLinks( (Robot)link.eContainer() )
        .select(l| l.childrenList.contains(link))
            .first()
;

Integer getID(AbstractLink this) :
    -1;//"Warning, no implementation of getID() for AbstractLink";
Integer getID(Link this) :
    this.num;
Integer getID(FixedRobotBase this) :
    0;
Integer getID(FloatingRobotBase this) :
    1;
Integer getID(Joint this) :
    this.num;
//This is a duplicate of the previous, to avoid a stupid bug: I call getID(Joint)
// and it complains about ambiguity for getID(Fixed/FloatingRobotBase) !??!
Integer getMyID(Joint this) :
    this.num;

//This returns the successor link of this joint
AbstractLink getSuccessorLink(Joint j) :
    (
    ((Robot)j.eContainer()).abstractLinks(). // for all links of the robot...
        select(link | link.childrenList.contains(j)).first(). // ... find the predecessor link of this joint ...
           childrenList.children.select(child | child.joint == j) // ... and select the good successor
                ).link
;

