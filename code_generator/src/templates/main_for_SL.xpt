«IMPORT iit::dsl::kinDsl»

«EXTENSION templates::common»

«DEFINE main FOR Robot»

«FILE this.name + "_mainforSL.cpp"»
#include <iostream>
#include <fstream>
#include <ctime>

#include "«name»_dynamics.h"

#include "SL.h"
#include "SL_kinematics.h"
#include "SL_dynamics.h"

#include "SL_user.h"

using namespace std;
using namespace iit::«name»;

static void fillState(StateVector& q, StateVector& qd, StateVector& qdd, SL_DJstate* desiredState);

/* This main is supposed to be used to test the inverse dynamics routines */
int main(int argc, char**argv)
{
    if(argc < 2) {
        cerr << "Please provide the number of tests to perform" << endl;
        return -1;
    }
    int numOfIterations =0;//= std::atoi(argv[1]);
    int numOfTests = std::atoi(argv[1]);
    double sl[numOfTests];
    double me[numOfTests];

    double t0, duration, sl_total, my_total;
    sl_total = 0;
    my_total = 0;

    iit::«name»::StateVector q, qd, qdd, tau;
    iit::«name»::Dynamics myDynamics;

    int t=0,i=0;

    SL_Jstate currentState[N_ROBOT_DOFS];
    SL_DJstate desiredState[N_ROBOT_DOFS];
    SL_endeff endeffector[N_ROBOT_ENDEFFECTORS];
    SL_Cstate basePosition;
    SL_quat baseOrient;

    init_kinematics();
    if( ! init_dynamics() ) {
        cerr << "Error in init_dynamics()" << endl;
        exit(-1);
    }

    for(i=0; i<N_ROBOT_DOFS; i++) {
        currentState[i].th   = 0;
        currentState[i].thd  = 0;
        currentState[i].thdd = 0;

        desiredState[i].th   = 0;
        desiredState[i].thd  = 0;
        desiredState[i].thdd = 0;

        desiredState[i].uff  = 0;
        desiredState[i].uex  = 0;
    }

    endeffector[LF_LEG].m = 0; // zero mass -> no endeffector
    for(i=0; i<=N_CART; i++) {
        basePosition.x[i]   = 0;
        basePosition.xd[i]  = 0;
        basePosition.xdd[i] = 0;

        endeffector[LF_LEG].mcm[i] = 0;
        endeffector[LF_LEG].cf[i]  = 0;
        endeffector[LF_LEG].ct[i]  = 0;
        endeffector[LF_LEG].x[i]   = 0;
        endeffector[LF_LEG].a[i]   = 0;
    }
    baseOrient.q[_Q0_] = 1;
    baseOrient.q[_Q1_] = 0;
    baseOrient.q[_Q2_] = 0;
    baseOrient.q[_Q3_] = 0;


    std::srand(std::time(NULL)); // initialize random number generator


//    // Prints numerical results, for comparison
//    fillState(q, qd, qdd, desiredState);
//    SL_InvDynNE(NULL, desiredState, endeffector, &basePosition, &baseOrient);
//    myDynamics.id(q, qd, qdd, tau);
//
//    printf("%f\n %f\n %f\n %f\n \n", desiredState[SLIDER_Z].uff,
//            desiredState[LF_HAA].uff, desiredState[LF_HFE].uff, desiredState[LF_KFE].uff);
//    cout << tau << endl;
//    return 1;

    ofstream out("«name»_testdata.m");
    out << "«name»_test.iterations = [";

    for(t=0; t<numOfTests; t++) {
        sl_total = 0;
        my_total = 0;
        numOfIterations = std::pow(10,t+1);
        out << numOfIterations << " ";

        for(i=0; i<numOfIterations; i++) {
            fillState(q, qd, qdd, desiredState);

            t0 = std::clock();
            SL_InvDynNE(NULL, desiredState, endeffector, &basePosition, &baseOrient);
            duration = std::clock() - t0;
            sl_total += duration;

            t0 = std::clock();
            myDynamics.id(q, qd, qdd, tau);
            duration = std::clock() - t0;
            my_total += duration;
        }
        sl[t] = sl_total/CLOCKS_PER_SEC;
        me[t] = my_total/CLOCKS_PER_SEC;
    }


    out << "];" << endl;
    // SL times
    out << "«name»_test.sl = [";
    for(t=0; t<numOfTests; t++) {
        out << sl[t] << " ";
    }
    out << "];" << endl;
    // My times
    out << "«name»_test.me = [";
    for(t=0; t<numOfTests; t++) {
        out << me[t] << " ";
    }
    out << "];" << endl;

    for(t=0; t<numOfTests; t++) {
        cout << "SL: " << sl[t] << "\t Me: " << me[t] << endl;
    }

    return TRUE;
}


void fillState(StateVector& q, StateVector& qd, StateVector& qdd, SL_DJstate* desiredState) {
    static const double max = 12.3;
«FOREACH joints AS j-»
    q(«j.getID()-1»)   = ( ((double)std::rand()) / RAND_MAX) * max;
    qd(«j.getID()-1»)  = ( ((double)std::rand()) / RAND_MAX) * max;
    qdd(«j.getID()-1») = ( ((double)std::rand()) / RAND_MAX) * max;
«ENDFOREACH»
    //TODO this part needs manual adaption!!
    desiredState[SLIDER_Z].th   = q(0);
    desiredState[SLIDER_Z].thd  = qd(0);
    desiredState[SLIDER_Z].thdd = qdd(0);
    desiredState[LF_HAA].th   = q(1);
    desiredState[LF_HAA].thd  = qd(1);
    desiredState[LF_HAA].thdd = qdd(1);
    desiredState[LF_HFE].th   = q(2);
    desiredState[LF_HFE].thd  = qd(2);
    desiredState[LF_HFE].thdd = qdd(2);
    desiredState[LF_KFE].th   = q(3);
    desiredState[LF_KFE].thd  = qd(3);
    desiredState[LF_KFE].thdd = qdd(3);
}

«ENDFILE»

«ENDDEFINE»«REM» Main «ENDREM»